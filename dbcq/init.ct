dbcq holds functions for db connection and querying.

``//__init__.py:
``import``
class dbcq:
    ``init``
    ``hasini``
    ``inipath``
    ``targets``
    ``query``
    ``qfa``
    ``qfad``
    ``info``
    ``_row_to_dict``    
``

init opens a db connection to a target from .dbc.

``/init:
    def __init__(self, target):
        ``.``
``

abort if no ini file. do this before the argparse else argparse
swallows it (even if this blocks dbcq -h).

``
        if not hasini():
            msg = f"""dbcq: {dbcq.inipath()} not found. please create the file and fill in:
[<target name>]
type = <mssql|sqlite>
database = <database name>
username = <user name>
password = <password>
server = <ip address>
port = <port>
driver = <driver>"""
            print(msg)
            raise Exception("no .dbc file")
``

get the database info for the target.

``
        self.target = target
        if target:
            self.info = dbinfo(target)
``

hasini returns whether there is a .dbc ini file in the home.

``/hasini:
    def hasini():
        return _dbc.hasini()
``

inipath gives the path where dbcq looks for the .dbc ini file (usually in the home).

``/inipath:
    def inipath():
        return _dbc.inipath()
``

targets gives the db targets from .dbc ini file.

``/targets:
    def targets():
        return _dbc.targets()
``

query executes query with optional values.

``/query:
    def query(self, query, *values):
        with dbconnect(target=self.target) as conn:
            cursor = conn.cursor()
            cursor.execute(query, *values)
            conn.commit()
``

qfa (query-fetch-all) executes query with optional values and returns
the results.

``/qfa:
    def qfa(self, query, *values):
        with dbconnect(target=self.target) as conn:
            cursor = conn.cursor()
            cursor.execute(query, *values)
            rows = cursor.fetchall()
            conn.commit()

            return rows
``

qfad (query-fetch-all-dict) returns query results as an array of dicts,
e.g. for json parsing.

``/qfad:
    def qfad(self, query, *values):
        if self.info["type"] == "mssql":
            ``mssql``
        elif self.info["type"] == "sqlite":
            ``sqlite``
        else:
            ``else``
``

for mssql, fold in the cursor description of the row.

``./mssql:
            rows = self.qfa(query, *values)
            dicts = [self._row_to_dict(row) for row in rows]
            return dicts
``

for sqlite, use row factory. from https://stackoverflow.com/a/41920171

``../sqlite:
            with dbconnect(target=self.target) as conn:
                cursor = conn.cursor()
                cursor.row_factory = sqlite3.Row
                cursor.execute(query, values) # pass as tuple, see https://stackoverflow.com/a/16856730
                rows = cursor.fetchall()
                conn.commit()

                dicts = [dict(row) for row in rows]
                return dicts
``

else, say not supported.

``../else:
              print(f"db type {self.info['type']} is currently not supported.")
``

info returns database info.

``/info:
    def info(self):
        return self.info
``    

_row_to_dict turns pyodbc-rows to dict:

``/_row_to_dict:
    def _row_to_dict(self, row):
        # lowercase column names
        columns = [tup[0].lower() for tup in row.cursor_description]
        # use column names as dict keys
        return dict(zip([c for c in columns], row))
``

the imports.

``/import:
from dbcq._dbc import *
import sys
``